import { Questions, UserQuestions } from "../models/models.js";import ApiError from "../error/apiError.js";import {  randomRange,  clamp,  shuffle,  stringToBoolean,} from "../utils/index.js";import { Categories } from "../models/models.js";import { Op } from "sequelize";class TrainerController {  async new(req, res, next) {    const { categoriesIds } = req.body;    try {      const randomQuestions = await TrainerController.#assignRandomQuestions(        categoriesIds,        req.user.id,        5      );      res.json(randomQuestions);    } catch (e) {      return next(ApiError.badRequest(e.message));    }  }  async repeat(req, res) {    const { categoriesIds } = req.body;    const randomQuestions = await TrainerController.#getQuestionsToRepeat(      categoriesIds,      req.user.id,      5    );    res.json(randomQuestions);  }  async compo(req, res, next) {    const { categoriesIds } = req.body;    let count = 5;    const questionsToRepeat = await TrainerController.#getQuestionsToRepeat(      categoriesIds,      req.user.id,      3    );    count -= questionsToRepeat.length;    const newQuestions = await TrainerController.#assignRandomQuestions(      categoriesIds,      req.user.id,      count    );    const questions = shuffle([...questionsToRepeat, ...newQuestions]);    if (!questions.length) {      return next(ApiError.badRequest("Некорректные данные"));    }    res.json(questions);  }  async question(req, res, next) {    const {      query: { correct },      params: { id },      user: { id: userId },    } = req;    const isCorrect = stringToBoolean(correct);    const question = await UserQuestions.findOne({      where: { userId, questionId: id },    });    if (!question) return next(ApiError.badRequest("Вопроса не существует"));    question.successes_in_row = isCorrect ? question.successes_in_row + 1 : 0;    await question.save();    res.status(204).json();  }  async resetCategoryProgress(req, res, next) {    const { id } = req.params;    const category = await Categories.findOne({      where: { id },      include: { model: Questions, as: "questions" },    });    if (!category) return next(ApiError.badRequest("Категории не существует"));    const questionsIds = category.questions.map((q) => q.id);    await UserQuestions.destroy({      where: { userId: req.user.id, questionId: questionsIds },    });    res.status(204).json();  }  async resetProgress(req, res, next) {    try {      await UserQuestions.destroy({ where: { userId: req.user.id } });      res.status(204).json();    } catch (e) {      return next(ApiError.internal());    }  }  static async #assignRandomQuestions(categoriesIds, userId, count) {    const questions = await Questions.findAll({      where: { categoryId: categoriesIds },      include: { model: Categories, as: "category" },      attributes: { exclude: "categoryId" },    });    if (!questions.length)      throw new Error("В одной из категорий отсутствуют вопросы");    const alreadyStudiedQuestions = await UserQuestions.findAll({      where: [{ userId: userId }],      raw: true,    });    const availableQuestions = questions.filter(      (question) =>        !alreadyStudiedQuestions.find((q) => q.questionId === question.id)    );    const randomQuestions = TrainerController.#getRandomQuestions(      availableQuestions,      count    );    await UserQuestions.bulkCreate(      randomQuestions.map((q) => ({ questionId: q.id, userId: userId }))    );    return randomQuestions;  }  static #getRandomQuestions(sourceArray, count) {    const questionsCount = clamp(count, 0, sourceArray.length);    const randomQuestions = [];    const pool = [...sourceArray];    for (let i = 0; i < questionsCount; i++) {      const randomIndex = randomRange(0, pool.length - 1);      randomQuestions.push(pool[randomIndex]);      pool.splice(randomIndex, 1);    }    return randomQuestions;  }  static async #getQuestionsToRepeat(categoriesIds, userId, count) {    const questions = await UserQuestions.findAll({      where: { userId: userId, successes_in_row: { [Op.lt]: 5 } },    });    const availableQuestions = await Questions.findAll({      where: {        id: questions.map((q) => q.questionId),        categoryId: categoriesIds,      },      include: { model: Categories, as: "category" },      attributes: {        exclude: "categoryId",      },      raw: true,    });    return TrainerController.#getRandomQuestions(availableQuestions, count).map(      (q) => {        const question = questions.find((qstn) => qstn.questionId === q.id);        const {          "category.id": categoryId,          "category.name": categoryName,          "category.createdAt": createdAt,          "category.updatedAt": updatedAt,          ...newQuestion        } = q;        return {          ...newQuestion,          category: {            id: categoryId,            name: categoryName,            createdAt,            updatedAt,          },          successes_in_row: question?.successes_in_row || 0,        };      }    );  }}export const trainerController = new TrainerController();